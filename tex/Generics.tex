First method:
int GreaterCount<T, U>(IEnumerable<T> items, T x)
    where T : IComparable<T>;

What does the type constraint mean for the first method:
The first method only have one constraint which is "where T : IComparable<T>;". This given constraint defines and sets up a requirement
That for GreaterCount it will be using the IComparable Interface. For both methods, we are able to receive two different types, T and U.
These two types could be any type, fx integer and float, where it is required to give two types which can be the same. 
The constraint then adds that T must be comparable with itself. 
This means that two seperate instances of T needs to be comparable with eachtoher because of the IComparable interface constraint

Second method:
int GreaterCount<T, U>(IEnumerable<T> items, T x)
    where T : U
    where U : IComparable<U>;

What does the type constraint mean for the second method:
The second method have two constraints. The first is "where T : U" and the second is "where U : IComparable<U>;".
The two constrainst are in a way connected with eachother. Meaning that T needs to be comparable to U and U needs to 
be comparable with itself, since U is implementing the IComparable<U> interface.
U is required by the constraint to be comparable to itself and since we also have a constraint stating that T implements U, then
T is required to be comparable with U.

first:
T comparable with T
second
T comparable with U and U comparable with U